

// Namespaces reference classes from other places
using HackYourFuture.DotnetMasterclass.Lesson2.SharedClasses;

// Create an object and set properties
Person stijn = new Person();
stijn.Name = "Stijn";
stijn.Age = 25;

var Name = "hannes";

stijn.Print();

// Use object initializer and property initializers
var hannes = new Person
{
    Name = "Hannes",
    Age = 40
};

hannes.Print();

// Use constructors
var student = new Student("Rosa", "El Salvador");
Console.WriteLine(student);

var unknownStudent = new Student();
Console.WriteLine(unknownStudent);

// null means the variable has no value
Student nonExistingStudent = null;
// Throws exception
// Console.WriteLine(nonExistingStudent.Name);


// With inheritance, everything of the base class is available on the inhering classes
student.Age = -1;
student.Print();

// We cannot do this, because Mammal is abstract:
// Mammal dog = new Mammal();
// But this works:
Mammal dog = new Dog();

// Use a class from another assembly
// this works because of the 'using' at the top.
var myBoat = new Vehicle("My boat");
var boatName = myBoat.Name;
// Not accessible because it is protected
//myBoat.SetNewVehicleName("The new awesome name");

// but we can also use the full name instead
var myFerrari = new HackYourFuture.DotnetMasterclass.Lesson2.SharedClasses.Vehicle();

Console.WriteLine(myBoat);
// Convention: classes uppercase
class Person
{
    //Convention: private fields: _ + lowercase
    private int _age;

    // Full property syntax
    // Convention: properties uppercase
    public int Age
    {
        get
        {
            return _age;
        }
        set
        {
            if (value < 0)
                _age = 0;
            else if (value > 150)
                _age = 150;
            else
                _age = value;
        }
    }

    // Auto properties
    // The private field gets generated by the compiler
    public string Name { get; set; }

    // Methods hold the class's logic
    public void Print()
    {
        Console.WriteLine($"{Name} is {_age} years old.");
    }
}

// You can only inherit from 1 other class
class Student : Person
{
    
    public Student(string name, string country)
    {
        Name = name;
        CountryOfOrigin = country;
    }

    // Constructors can use other constructors
    // And you can have more than one
    public Student() : this("Unknown", "The world") { }

    public string CountryOfOrigin { get; set; }

    // This replaces the default ToString() method to output something more useful.
    public override string ToString()
    {
        return $"{Name} comes from {CountryOfOrigin}";
    }
}

// Always needs to be inherited from, can never be instantiated
// internal: can be used inside the ame assembly
internal abstract class Mammal
{
    // This MUST be implemented by inheriting classes, because of 'abstract'
    public abstract void Move();
}

class Dog : Mammal
{
    // This needs to be here for the code to compile
    public override void Move()
    {
        // A dog runs
    }
}